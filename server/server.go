// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package server implements the containerz gNOI service.
package server

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"os"
	"time"

	options "github.com/openconfig/containerz/containers"
	cpb "github.com/openconfig/gnoi/containerz"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"k8s.io/klog/v2"
)

type containerManager interface {

	// ContainerList list the containers on the target.
	//
	// It takes:
	// all (bool): return all containers regardless of state
	// limit (int32): return limit number of results.
	//
	// It returns an error indicating the result of the operation.
	ContainerList(context.Context, bool, int32, options.ListContainerStreamer, ...options.Option) error

	// ContainerPull pulls a container from a registry to this instance of containerz.
	//
	// It takes as input:
	// - image (string): a container image name.
	// - tag (string): a container image tag.
	// - opts (ImageOption slice): a set of options.
	//
	// It returns an error indicating the result of the operation.
	ContainerPull(context.Context, string, string, ...options.Option) error

	// ContainerPush pushes a container image to this instance of containerz.
	//
	// It takes as input:
	// - file (os.File): a file containing the tarball of the container.
	// - opts (ImageOption slice): a set of options.
	//
	// It returns:
	// - image (string): the container image name of the container that was pushed.
	// - tag (string): the container image tag of the container that was pushed
	ContainerPush(context.Context, *os.File, ...options.Option) (string, string, error)

	// ContainerRemove removes an image provided it is not linked to any running containers.
	//
	// It takes:
	// - image (string): the image name to remove.
	// - tag (string): the tage to remove
	//
	// It returns an error indicating if the remove operation succeeded.
	ContainerRemove(context.Context, string, string, ...options.Option) error

	// ContainerStart starts a container based on the supplied image and tag.
	//
	// It takes:
	// - image (string): the image to use
	// - tag (string): the tag to use
	// - cmd (string): a command to run.
	//
	// It returns an error indicating if the start operation succeeded along with the ID of the
	// started container.
	ContainerStart(context.Context, string, string, string, ...options.Option) (string, error)

	// ContainerStop stops a container. If the Force option is passed it will forcefully stop
	// (kill) the container. A stop timeout can be provided via the context otherwise the
	// system default will be used.
	//
	// It takes:
	// - instance (string): the instance name of the running container.
	//
	// It returns an error indicating whether the result was successful
	ContainerStop(context.Context, string, ...options.Option) error

	// ContainerLogs fetches the logs from a container. It can optionally follow the logs
	// and send them back to the client.
	//
	// It takes:
	// - instance (string): the instance name of the container.
	// - srv (LogStreamer): to stream the logs back to the client.
	//
	// It returns an error indicating whether the operation was successful or not.
	ContainerLogs(context.Context, string, options.LogStreamer, ...options.Option) error

	// VolumeList lists volumes on the target.
	//
	// It takes:
	// - optional filters
	//
	// It returns an error indicating the result of the operation.
	VolumeList(context.Context, options.ListVolumeStreamer, ...options.Option) error

	// VolumeCreate creates a volume. It will optionally apply labels or driver options to the volume
	// creation.
	//
	// It takes:
	// -  name (string): The name of the volume to create. If this this empty the name should be
	//		autogenerated.
	// -  driver (enum): The name of the driver to use. If this is empty the driver will default
	//		local driver.
	VolumeCreate(context.Context, string, cpb.Driver, ...options.Option) (string, error)

	// VolumeRemove removes a volume identified by the provided name.
	//
	// It takes:
	// - name (string): The name of the volume to remove.
	VolumeRemove(context.Context, string, ...options.Option) error
}

// Server represents a containerz service.
type Server struct {
	cpb.UnimplementedContainerzServer

	mgr        containerManager
	grpcServer *grpc.Server
	lis        net.Listener

	addr        string
	dockerHost  string
	tmpLocation string

	chunkSize int
}

// New constructs a new containerz server
func New(mgr containerManager, opts ...Option) *Server {
	cred, err := selfSignedCert()
	if err != nil {
		klog.Fatalf("unable to self sign a cert: %v", err)
	}
	s := &Server{
		grpcServer:  grpc.NewServer(grpc.Creds(cred)),
		tmpLocation: "/tmp",
		chunkSize:   5e6, // 5mb chunks
		mgr:         mgr,
		addr:        ":9999",
	}

	for _, opt := range opts {
		opt(s)
	}
	
	s.lis, err = net.Listen("tcp", s.addr)
	if err != nil {
		klog.Fatalf("server start: %e", err)
	}

	return s
}

// Serve starts this instance of the containerz server.
func (s *Server) Serve(ctx context.Context) error {
	klog.Info("server-start")
	cpb.RegisterContainerzServer(s.grpcServer, s)

	klog.Infof("Starting up on Containerz server, listening on: %s", s.lis.Addr())
	klog.Info("server-ready")
	return s.grpcServer.Serve(s.lis)
}

// Halt stops the containerz server gracefully.
func (s *Server) Halt(ctx context.Context) {
	klog.Info("server-stopping")
	if s.grpcServer != nil {
		s.grpcServer.GracefulStop()
	}
	klog.Info("server stopped")
}

func selfSignedCert() (credentials.TransportCredentials, error) {
	cert, err := newCert()
	if err != nil {
		return nil, err
	}
	return credentials.NewTLS(&tls.Config{
		Certificates: []tls.Certificate{cert},
		ServerName:   "containerz.openconfig.net",
	}), nil
}

func newCert() (tls.Certificate, error) {
	notBefore := time.Now()
	notAfter := notBefore.AddDate(0, 0, 7)

	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		return tls.Certificate{}, err
	}
	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{"OpenConfig"},
		},
		DNSNames:  []string{"containerz.openconfig.net"},
		NotBefore: notBefore,
		NotAfter:  notAfter,

		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return tls.Certificate{}, err
	}
	derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
	if err != nil {
		return tls.Certificate{}, err
	}

	certBuf := &bytes.Buffer{}
	pem.Encode(certBuf, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
	keyBuf := &bytes.Buffer{}
	pem.Encode(keyBuf, &pem.Block{Type: "EC PRIVATE KEY", Bytes: pemBlockForKey(priv)})

	return tls.X509KeyPair(certBuf.Bytes(), keyBuf.Bytes())
}

func pemBlockForKey(priv any) []byte {
	switch k := priv.(type) {
	case *ecdsa.PrivateKey:
		b, err := x509.MarshalECPrivateKey(k)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to marshal ECDSA private key: %v", err)
			os.Exit(2)
		}
		return b
	default:
		return nil
	}
}
